<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NewTon - Tournament Manager</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #000000 0%, #333333 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            color: #000000;
            font-size: 2rem;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo-placeholder {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #000000 0%, #333333 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            border: 3px solid #ddd;
            text-align: center;
            line-height: 1.2;
        }

        .nav {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .nav button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: #000000;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
        }

        .nav button:hover {
            background: #333333;
        }

        .nav button.active {
            background: #ff6b35;
        }

        .page {
            display: none;
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .page.active {
            display: block;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #000000;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #000000;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            background: #000000;
            color: white;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.3s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .btn:hover {
            background: #333333;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #28a745;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-danger {
            background: #dc3545;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        .players-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .player-card {
            background: #f8f9fa;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            transition: all 0.3s;
        }

        .player-card:hover {
            border-color: #000000;
        }

        .player-card.paid {
            border-color: #28a745;
            background: #d4edda;
        }

        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .player-name {
            font-weight: bold;
            font-size: 18px;
            color: #000000;
        }

        .paid-checkbox {
            transform: scale(1.2);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tournament-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        /* BRACKET STYLES */
        .bracket-container {
            position: relative;
            width: 100%;
            height: 80vh;
            background: #f5f5f5;
            border: 8px solid #333333;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .bracket-viewport {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
            cursor: grab;
        }

        .bracket-viewport:active {
            cursor: grabbing;
        }

        .bracket-canvas {
            position: relative;
            width: 2000px;
            height: 1200px;
            background: #f5f5f5;
            transform-origin: 0 0;
            transition: transform 0.1s ease-out;
        }

        .bracket-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            background: rgba(0,0,0,0.8);
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            background: rgba(0,0,0,0.9);
        }

        .bracket-title {
            position: absolute;
            top: 50px;
            font-size: 48px;
            font-weight: bold;
            color: #333333;
            letter-spacing: 8px;
            text-transform: uppercase;
        }

        .bracket-title.back {
            left: 200px;
        }

        .bracket-title.front {
            right: 200px;
        }

        .bracket-match {
            position: absolute;
            width: 180px;
            height: 80px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            font-size: 11px;
            transition: all 0.3s;
            cursor: pointer;
            z-index: 10;
        }

        .bracket-match:hover {
            border-color: #ff6b35;
            box-shadow: 0 4px 12px rgba(255,107,53,0.3);
            z-index: 20;
        }

        .bracket-match.active {
            border-color: #ff6b35;
            background: #fff8f0;
        }

        .bracket-match.completed {
            background: #f0f8ff;
            border-color: #28a745;
        }

        .match-header {
            background: #f8f9fa;
            padding: 3px 8px;
            font-weight: bold;
            font-size: 10px;
            text-align: center;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .match-info {
            font-size: 9px;
            color: #666;
        }

        .match-players {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .match-player {
            flex: 1;
            padding: 6px 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #eee;
            transition: background 0.2s;
            cursor: pointer;
        }

        .match-player:last-child {
            border-bottom: none;
        }

        .match-player:hover {
            background: #f8f9fa;
        }

        .match-player.winner {
            background: #d4edda;
            font-weight: bold;
        }

        .match-player.first-throw {
            border-left: 3px solid #ff6b35;
        }

        .match-player.bye {
            background: #f8f9fa;
            color: #666;
            font-style: italic;
            cursor: default;
        }

        .player-name-short {
            font-size: 11px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100px;
        }

        .winner-check {
            color: #28a745;
            font-weight: bold;
            font-size: 14px;
        }

        .match-controls {
            padding: 3px 8px;
            background: #f8f9fa;
            border-top: 1px solid #ddd;
            font-size: 9px;
            display: flex;
            justify-content: space-between;
        }

        .bracket-line {
            position: absolute;
            background: #333333;
            z-index: 1;
        }

        .bracket-line.horizontal {
            height: 3px;
        }

        .bracket-line.vertical {
            width: 3px;
        }

        .config-section {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .config-section h3 {
            color: #000000;
            margin-bottom: 15px;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .results-table th,
        .results-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .results-table th {
            background: #000000;
            color: white;
            font-weight: bold;
        }

        .results-table tr:nth-child(even) {
            background: #f8f9fa;
        }

        .results-table tr:hover {
            background: #e9ecef;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 10px;
            width: 80%;
            max-width: 600px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            margin-top: -10px;
        }

        .close:hover {
            color: #000;
        }

        .alert {
            padding: 15px;
            margin: 15px 0;
            border: 1px solid transparent;
            border-radius: 5px;
        }

        .alert-info {
            color: #0c5460;
            background-color: #d1ecf1;
            border-color: #bee5eb;
        }

        .alert-success {
            color: #155724;
            background-color: #d4edda;
            border-color: #c3e6cb;
        }

        .alert-warning {
            color: #856404;
            background-color: #fff3cd;
            border-color: #ffeaa7;
        }

        @media (max-width: 768px) {
            .tournament-info {
                grid-template-columns: 1fr;
            }
            
            .players-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-top">
                <h1>
                    <div class="logo-placeholder">
                        CLUB<br>LOGO
                    </div>
                    NewTon - Tournament Manager
                </h1>
            </div>
            <div class="nav">
                <button class="nav-btn active" data-page="setup">Setup</button>
                <button class="nav-btn" data-page="registration">Registration</button>
                <button class="nav-btn" data-page="tournament">Tournament</button>
                <button class="nav-btn" data-page="config">Config</button>
            </div>
        </div>

        <!-- Setup Page -->
        <div id="setup" class="page active">
            <h2>Tournament Setup</h2>
            <div class="tournament-info">
                <div class="form-group">
                    <label for="tournamentName">Tournament Name</label>
                    <input type="text" id="tournamentName" placeholder="Enter tournament name">
                </div>
                <div class="form-group">
                    <label for="tournamentDate">Tournament Date</label>
                    <input type="date" id="tournamentDate">
                </div>
            </div>
            
            <div class="form-group">
                <button class="btn btn-success" onclick="createTournament()">Create New Tournament</button>
                <button class="btn" onclick="loadTournament()">Load Existing Tournament</button>
                <button class="btn btn-warning" onclick="exportTournament()">Export Tournament</button>
            </div>

            <div id="tournamentStatus" class="alert alert-info" style="display: none;">
                No active tournament
            </div>

            <div class="config-section">
                <h3>Recent Tournaments</h3>
                <div id="recentTournaments">
                    <p>No tournaments found</p>
                </div>
            </div>
        </div>

        <!-- Registration Page -->
        <div id="registration" class="page">
            <h2>Player Registration</h2>
            
            <div class="form-group">
                <label for="playerName">Add New Player</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="playerName" placeholder="Enter player name" style="flex: 1;">
                    <button class="btn btn-success" onclick="addPlayer()">Add Player</button>
                </div>
            </div>

            <div style="display: flex; justify-content: space-between; align-items: center; margin: 20px 0;">
                <h3>Players (<span id="playerCount">0</span> total, <span id="paidCount">0</span> paid)</h3>
                <div>
                    <button class="btn" onclick="generateBracket()">Generate Bracket</button>
                    <button class="btn btn-danger" onclick="clearAllPlayers()">Clear All</button>
                </div>
            </div>

            <div id="playersContainer" class="players-grid">
                <!-- Players will be added here -->
            </div>

            <!-- Results Section -->
            <div id="resultsSection" style="margin-top: 40px; display: none;">
                <h3>Tournament Results</h3>
                <table class="results-table">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Player</th>
                            <th>Points</th>
                            <th>Short Legs</th>
                            <th>High Outs</th>
                            <th>Tons</th>
                            <th>180s</th>
                        </tr>
                    </thead>
                    <tbody id="resultsTableBody">
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Tournament Page -->
        <div id="tournament" class="page">
            <h2>Double Elimination Bracket</h2>
            
            <div id="tournamentControls" style="margin-bottom: 20px;">
                <button class="btn" onclick="autoAssignReferees()">Auto-Assign Referees</button>
                <button class="btn btn-warning" onclick="resetTournament()">Reset Tournament</button>
                <button class="btn" onclick="showMatchDetails()">Match Details</button>
            </div>

            <div class="bracket-container">
                <div class="bracket-controls">
                    <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out">−</button>
                    <button class="zoom-btn" onclick="resetZoom()" title="Reset Zoom">⌂</button>
                    <button class="zoom-btn" onclick="zoomIn()" title="Zoom In">+</button>
                </div>
                
                <div class="bracket-viewport" id="bracketViewport">
                    <div class="bracket-canvas" id="bracketCanvas">
                        <div class="bracket-title back">BACKSIDE</div>
                        <div class="bracket-title front">FRONTSIDE</div>
                        
                        <div id="bracketMatches">
                            <!-- Bracket matches will be rendered here -->
                        </div>
                        
                        <div id="bracketLines">
                            <!-- Connection lines will be rendered here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Configuration Page -->
        <div id="config" class="page">
            <h2>Tournament Configuration</h2>
            
            <div class="config-section">
                <h3>Point Values</h3>
                <div class="config-grid">
                    <div class="form-group">
                        <label for="participationPoints">Participation Points</label>
                        <input type="number" id="participationPoints" value="1" min="0">
                    </div>
                    <div class="form-group">
                        <label for="firstPlacePoints">1st Place Points</label>
                        <input type="number" id="firstPlacePoints" value="3" min="0">
                    </div>
                    <div class="form-group">
                        <label for="secondPlacePoints">2nd Place Points</label>
                        <input type="number" id="secondPlacePoints" value="2" min="0">
                    </div>
                    <div class="form-group">
                        <label for="thirdPlacePoints">3rd Place Points</label>
                        <input type="number" id="thirdPlacePoints" value="1" min="0">
                    </div>
                    <div class="form-group">
                        <label for="highOutPoints">High Out Points (101+)</label>
                        <input type="number" id="highOutPoints" value="1" min="0">
                    </div>
                    <div class="form-group">
                        <label for="tonPoints">Ton Points (100+)</label>
                        <input type="number" id="tonPoints" value="1" min="0">
                    </div>
                    <div class="form-group">
                        <label for="oneEightyPoints">180 Points</label>
                        <input type="number" id="oneEightyPoints" value="1" min="0">
                    </div>
                </div>
                <button class="btn btn-success" onclick="saveConfiguration()">Save Configuration</button>
            </div>

            <div class="config-section">
                <h3>Match Configuration</h3>
                <div class="config-grid">
                    <div class="form-group">
                        <label for="round1Legs">Round 1 Legs</label>
                        <select id="round1Legs">
                            <option value="3">Best of 3</option>
                            <option value="5">Best of 5</option>
                            <option value="7">Best of 7</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="round2Legs">Round 2 Legs</label>
                        <select id="round2Legs">
                            <option value="3">Best of 3</option>
                            <option value="5">Best of 5</option>
                            <option value="7">Best of 7</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="semifinalLegs">Semi-Final Legs</label>
                        <select id="semifinalLegs">
                            <option value="3">Best of 3</option>
                            <option value="5" selected>Best of 5</option>
                            <option value="7">Best of 7</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="finalLegs">Final Legs</label>
                        <select id="finalLegs">
                            <option value="3">Best of 3</option>
                            <option value="5" selected>Best of 5</option>
                            <option value="7">Best of 7</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Statistics Modal -->
    <div id="statsModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeStatsModal()">&times;</span>
            <h3 id="statsPlayerName">Player Statistics</h3>
            <div class="form-group">
                <label>Short Legs (max 21 darts)</label>
                <input type="number" id="statsShortLegs" min="0" max="21">
            </div>
            <div class="form-group">
                <label>High Out Score (101+)</label>
                <input type="number" id="statsHighOut" min="101" max="170">
                <button class="btn" onclick="addHighOut()">Add High Out</button>
            </div>
            <div class="form-group">
                <label>Tons (100+)</label>
                <input type="number" id="statsTons" min="0">
            </div>
            <div class="form-group">
                <label>180s</label>
                <input type="number" id="stats180s" min="0">
            </div>
            <div id="highOutsList" style="margin-top: 10px;"></div>
            <div style="margin-top: 20px;">
                <button class="btn btn-success" onclick="saveStats()">Save Statistics</button>
                <button class="btn" onclick="closeStatsModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let tournament = null;
        let players = [];
        let matches = [];
        let config = {
            points: {
                participation: 1,
                first: 3,
                second: 2,
                third: 1,
                highOut: 1,
                ton: 1,
                oneEighty: 1
            },
            legs: {
                round1: 3,
                round2: 3,
                semifinal: 5,
                final: 5
            }
        };
        let currentStatsPlayer = null;
        let zoomLevel = 0.6; // Start zoomed out to show full tournament
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let panOffset = { x: 0, y: 0 };

        // Initialize application
        document.addEventListener('DOMContentLoaded', function() {
            loadConfiguration();
            loadRecentTournaments();
            setupEventListeners();
            setTodayDate();
        });

        function setTodayDate() {
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('tournamentDate').value = today;
        }

        function setupEventListeners() {
            // Navigation
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const page = this.dataset.page;
                    showPage(page);
                });
            });

            // Enter key handlers
            document.getElementById('playerName').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    addPlayer();
                }
            });

            // Auto-save configuration
            ['participationPoints', 'firstPlacePoints', 'secondPlacePoints', 'thirdPlacePoints', 
             'highOutPoints', 'tonPoints', 'oneEightyPoints'].forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('change', function() {
                        const key = id.replace('Points', '').replace('first', 'first').replace('second', 'second').replace('third', 'third').replace('oneEighty', 'oneEighty');
                        config.points[key] = parseInt(this.value);
                        saveConfiguration();
                    });
                }
            });

            // Bracket zoom and pan controls
            const viewport = document.getElementById('bracketViewport');
            if (viewport) {
                viewport.addEventListener('wheel', handleZoom);
                viewport.addEventListener('mousedown', startDrag);
                viewport.addEventListener('mousemove', handleDrag);
                viewport.addEventListener('mouseup', endDrag);
                viewport.addEventListener('mouseleave', endDrag);
            }
        }

        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            document.getElementById(pageId).classList.add('active');
            document.querySelector(`[data-page="${pageId}"]`).classList.add('active');
        }

        function createTournament() {
            const name = document.getElementById('tournamentName').value.trim();
            const date = document.getElementById('tournamentDate').value;
            
            if (!name || !date) {
                alert('Please enter both tournament name and date');
                return;
            }

            tournament = {
                id: Date.now(),
                name: name,
                date: date,
                created: new Date().toISOString(),
                status: 'setup',
                players: [],
                matches: [],
                bracket: null
            };

            players = [];
            matches = [];
            
            saveTournament();
            updateTournamentStatus();
            showPage('registration');
            
            alert('Tournament created successfully!');
        }

        function loadTournament() {
            const tournaments = JSON.parse(localStorage.getItem('dartsTournaments') || '[]');
            if (tournaments.length === 0) {
                alert('No tournaments found');
                return;
            }

            const tournamentList = tournaments.map(t => 
                `${t.id}: ${t.name} (${t.date})`
            ).join('\n');
            
            const selectedId = prompt('Select tournament by ID:\n' + tournamentList);
            if (!selectedId) return;

            const selectedTournament = tournaments.find(t => t.id == selectedId);
            if (!selectedTournament) {
                alert('Tournament not found');
                return;
            }

            tournament = selectedTournament;
            players = tournament.players || [];
            matches = tournament.matches || [];
            
            document.getElementById('tournamentName').value = tournament.name;
            document.getElementById('tournamentDate').value = tournament.date;
            
            updateTournamentStatus();
            updatePlayersDisplay();
            updatePlayerCount();
            
            if (tournament.bracket) {
                renderBracket();
            }
            
            showPage('registration');
            alert('Tournament loaded successfully!');
        }

        function exportTournament() {
            if (!tournament) {
                alert('No active tournament to export');
                return;
            }

            const dataStr = JSON.stringify(tournament, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${tournament.name}_${tournament.date}.json`;
            link.click();
        }

        function saveTournament() {
            if (!tournament) return;

            tournament.players = players;
            tournament.matches = matches;
            tournament.lastSaved = new Date().toISOString();

            let tournaments = JSON.parse(localStorage.getItem('dartsTournaments') || '[]');
            const index = tournaments.findIndex(t => t.id === tournament.id);
            
            if (index >= 0) {
                tournaments[index] = tournament;
            } else {
                tournaments.push(tournament);
            }
            
            localStorage.setItem('dartsTournaments', JSON.stringify(tournaments));
            localStorage.setItem('currentTournament', JSON.stringify(tournament));
        }

        function updateTournamentStatus() {
            const statusDiv = document.getElementById('tournamentStatus');
            if (tournament) {
                statusDiv.innerHTML = `Active Tournament: <strong>${tournament.name}</strong> (${tournament.date})`;
                statusDiv.className = 'alert alert-success';
                statusDiv.style.display = 'block';
            } else {
                statusDiv.innerHTML = 'No active tournament';
                statusDiv.className = 'alert alert-info';
                statusDiv.style.display = 'block';
            }
        }

        function loadRecentTournaments() {
            const tournaments = JSON.parse(localStorage.getItem('dartsTournaments') || '[]');
            const container = document.getElementById('recentTournaments');
            
            if (tournaments.length === 0) {
                container.innerHTML = '<p>No tournaments found</p>';
                return;
            }

            const html = tournaments.slice(-5).reverse().map(t => `
                <div style="padding: 10px; border: 1px solid #ddd; border-radius: 5px; margin-bottom: 10px;">
                    <strong>${t.name}</strong> (${t.date}) 
                    <button class="btn" style="padding: 5px 10px; font-size: 14px;" onclick="loadSpecificTournament(${t.id})">Load</button>
                </div>
            `).join('');
            
            container.innerHTML = html;
        }

        function loadSpecificTournament(id) {
            const tournaments = JSON.parse(localStorage.getItem('dartsTournaments') || '[]');
            const selectedTournament = tournaments.find(t => t.id === id);
            
            if (!selectedTournament) {
                alert('Tournament not found');
                return;
            }

            tournament = selectedTournament;
            players = tournament.players || [];
            matches = tournament.matches || [];
            
            document.getElementById('tournamentName').value = tournament.name;
            document.getElementById('tournamentDate').value = tournament.date;
            
            updateTournamentStatus();
            updatePlayersDisplay();
            updatePlayerCount();
            
            if (tournament.bracket) {
                renderBracket();
            }
            
            showPage('registration');
        }

        function addPlayer() {
            const nameInput = document.getElementById('playerName');
            const name = nameInput.value.trim();
            
            if (!name) {
                alert('Please enter a player name');
                return;
            }

            if (players.find(p => p.name.toLowerCase() === name.toLowerCase())) {
                alert('Player already exists');
                return;
            }

            const player = {
                id: Date.now(),
                name: name,
                paid: false,
                stats: {
                    shortLegs: 0,
                    highOuts: [],
                    tons: 0,
                    oneEighties: 0
                },
                placement: null,
                eliminated: false
            };

            players.push(player);
            nameInput.value = '';
            
            updatePlayersDisplay();
            updatePlayerCount();
            saveTournament();
        }

        function removePlayer(playerId) {
            if (confirm('Are you sure you want to remove this player?')) {
                players = players.filter(p => p.id !== playerId);
                updatePlayersDisplay();
                updatePlayerCount();
                saveTournament();
            }
        }

        function togglePaid(playerId) {
            const player = players.find(p => p.id === playerId);
            if (player) {
                player.paid = !player.paid;
                updatePlayersDisplay();
                updatePlayerCount();
                saveTournament();
            }
        }

        function openStatsModal(playerId) {
            const player = players.find(p => p.id === playerId);
            if (!player) return;

            currentStatsPlayer = player;
            document.getElementById('statsPlayerName').textContent = `${player.name} - Statistics`;
            document.getElementById('statsShortLegs').value = player.stats.shortLegs || 0;
            document.getElementById('statsTons').value = player.stats.tons || 0;
            document.getElementById('stats180s').value = player.stats.oneEighties || 0;
            
            updateHighOutsList();
            document.getElementById('statsModal').style.display = 'block';
        }

        function addHighOut() {
            const score = parseInt(document.getElementById('statsHighOut').value);
            if (!score || score < 101 || score > 170) {
                alert('Please enter a valid high out score (101-170)');
                return;
            }

            if (!currentStatsPlayer.stats.highOuts) {
                currentStatsPlayer.stats.highOuts = [];
            }

            currentStatsPlayer.stats.highOuts.push(score);
            document.getElementById('statsHighOut').value = '';
            updateHighOutsList();
        }

        function updateHighOutsList() {
            const container = document.getElementById('highOutsList');
            if (!currentStatsPlayer || !currentStatsPlayer.stats.highOuts) {
                container.innerHTML = '';
                return;
            }

            const html = currentStatsPlayer.stats.highOuts.map((score, index) => `
                <span style="background: #f8f9fa; padding: 5px 10px; margin: 2px; border-radius: 3px; display: inline-block;">
                    ${score} <button onclick="removeHighOut(${index})" style="background: none; border: none; color: red; cursor: pointer;">×</button>
                </span>
            `).join('');
            
            container.innerHTML = `<div style="margin-top: 10px;"><strong>High Outs:</strong><br>${html}</div>`;
        }

        function removeHighOut(index) {
            if (currentStatsPlayer && currentStatsPlayer.stats.highOuts) {
                currentStatsPlayer.stats.highOuts.splice(index, 1);
                updateHighOutsList();
            }
        }

        function saveStats() {
            if (!currentStatsPlayer) return;

            currentStatsPlayer.stats.shortLegs = parseInt(document.getElementById('statsShortLegs').value) || 0;
            currentStatsPlayer.stats.tons = parseInt(document.getElementById('statsTons').value) || 0;
            currentStatsPlayer.stats.oneEighties = parseInt(document.getElementById('stats180s').value) || 0;

            updatePlayersDisplay();
            saveTournament();
            closeStatsModal();
        }

        function closeStatsModal() {
            document.getElementById('statsModal').style.display = 'none';
            currentStatsPlayer = null;
        }

        function updatePlayersDisplay() {
            const container = document.getElementById('playersContainer');
            
            if (players.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666;">No players added yet</p>';
                return;
            }

            const html = players.map(player => `
                <div class="player-card ${player.paid ? 'paid' : ''}">
                    <div class="player-header">
                        <span class="player-name">${player.name}</span>
                        <div>
                            <label style="margin-right: 10px;">
                                <input type="checkbox" class="paid-checkbox" ${player.paid ? 'checked' : ''} 
                                       onchange="togglePaid(${player.id})"> Paid
                            </label>
                            <button onclick="removePlayer(${player.id})" style="background: #dc3545; color: white; border: none; border-radius: 3px; padding: 5px 8px; cursor: pointer;">×</button>
                        </div>
                    </div>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <span>Short Legs:</span>
                            <span>${player.stats.shortLegs || 0}</span>
                        </div>
                        <div class="stat-item">
                            <span>High Outs:</span>
                            <span>${(player.stats.highOuts || []).length}</span>
                        </div>
                        <div class="stat-item">
                            <span>Tons:</span>
                            <span>${player.stats.tons || 0}</span>
                        </div>
                        <div class="stat-item">
                            <span>180s:</span>
                            <span>${player.stats.oneEighties || 0}</span>
                        </div>
                    </div>
                    <button class="btn" style="width: 100%; margin-top: 10px; padding: 8px;" onclick="openStatsModal(${player.id})">
                        Edit Statistics
                    </button>
                </div>
            `).join('');

            container.innerHTML = html;
        }

        function updatePlayerCount() {
            const totalPlayers = players.length;
            const paidPlayers = players.filter(p => p.paid).length;
            
            document.getElementById('playerCount').textContent = totalPlayers;
            document.getElementById('paidCount').textContent = paidPlayers;
        }

        function clearAllPlayers() {
            if (confirm('Are you sure you want to remove all players? This cannot be undone.')) {
                players = [];
                updatePlayersDisplay();
                updatePlayerCount();
                saveTournament();
            }
        }

        function generateBracket() {
            if (!tournament) {
                alert('Please create a tournament first');
                return;
            }

            const paidPlayers = players.filter(p => p.paid);
            if (paidPlayers.length < 2) {
                alert('Need at least 2 paid players to generate bracket');
                return;
            }

            // Determine bracket size
            let bracketSize;
            if (paidPlayers.length <= 8) bracketSize = 8;
            else if (paidPlayers.length <= 16) bracketSize = 16;
            else if (paidPlayers.length <= 32) bracketSize = 32;
            else bracketSize = 48;

            // Shuffle players randomly
            const shuffledPlayers = [...paidPlayers].sort(() => Math.random() - 0.5);
            
            // Create bracket - fill first round completely with players and walkovers
            const bracket = [];
            
            // Add all real players
            shuffledPlayers.forEach(player => {
                bracket.push(player);
            });
            
            // Fill remaining first round spots with walkovers
            for (let i = shuffledPlayers.length; i < bracketSize; i++) {
                bracket.push({ id: `walkover-${i}`, name: 'Walkover', isBye: true });
            }

            tournament.bracket = bracket;
            tournament.bracketSize = bracketSize;
            tournament.status = 'active';
            
            generateMatches();
            saveTournament();
            renderBracket();
            showPage('tournament');
            
            alert(`Bracket generated with ${bracketSize} positions for ${paidPlayers.length} players`);
        }

        function generateMatches() {
            matches = [];
            const bracket = tournament.bracket;
            const bracketSize = tournament.bracketSize;
            
            // Calculate bracket structure
            const structure = calculateBracketStructure(bracketSize);
            
            // Generate complete double elimination bracket
            generateCompleteBracket(bracket, structure);
        }

        function calculateBracketStructure(bracketSize) {
            const frontsideRounds = Math.ceil(Math.log2(bracketSize));
            
            // Double elimination backside structure
            const backsideRounds = (frontsideRounds - 1) * 2;
            
            // Calculate matches per round for frontside
            const frontsideStructure = [];
            for (let round = 1; round <= frontsideRounds; round++) {
                const matchesInRound = Math.pow(2, frontsideRounds - round);
                frontsideStructure.push({
                    round: round,
                    matches: matchesInRound,
                    isLast: round === frontsideRounds
                });
            }
            
            // Calculate matches per round for backside
            const backsideStructure = [];
            for (let round = 1; round <= backsideRounds; round++) {
                let matchesInRound;
                
                if (round === 1) {
                    // First backside round: half of first frontside losers
                    matchesInRound = Math.pow(2, frontsideRounds - 2);
                } else if (round % 2 === 0) {
                    // Even rounds: merge with frontside losers
                    const frontsideRoundLosers = Math.floor((round / 2) + 1);
                    matchesInRound = Math.pow(2, frontsideRounds - frontsideRoundLosers - 1);
                } else {
                    // Odd rounds: advance backside winners
                    matchesInRound = Math.pow(2, frontsideRounds - Math.ceil(round / 2) - 1);
                }
                
                matchesInRound = Math.max(1, matchesInRound);
                backsideStructure.push({
                    round: round,
                    matches: matchesInRound,
                    receivesFromFrontside: round % 2 === 0
                });
            }
            
            return {
                frontside: frontsideStructure,
                backside: backsideStructure,
                frontsideRounds: frontsideRounds,
                backsideRounds: backsideRounds
            };
        }

        function generateCompleteBracket(bracket, structure) {
            let matchId = 1;
            
            // Generate frontside matches
            generateFrontsideMatches(bracket, structure, matchId);
            matchId = matches.length + 1;
            
            // Generate backside matches
            generateBacksideMatches(structure, matchId);
            matchId = matches.length + 1;
            
            // Generate final matches
            generateFinalMatches(matchId);
        }

        function generateFrontsideMatches(bracket, structure, startId) {
            let matchId = startId;
            
            structure.frontside.forEach((roundInfo, roundIndex) => {
                for (let matchIndex = 0; matchIndex < roundInfo.matches; matchIndex++) {
                    let player1, player2;
                    
                    if (roundIndex === 0) {
                        // First round: use actual players
                        const playerIndex = matchIndex * 2;
                        player1 = bracket[playerIndex] || { name: 'BYE', id: `bye-${playerIndex}`, isBye: true };
                        player2 = bracket[playerIndex + 1] || { name: 'BYE', id: `bye-${playerIndex + 1}`, isBye: true };
                    } else {
                        // Later rounds: TBD players from previous matches
                        player1 = { name: 'TBD', id: `fs-${roundInfo.round}-${matchIndex}-1` };
                        player2 = { name: 'TBD', id: `fs-${roundInfo.round}-${matchIndex}-2` };
                    }
                    
                    const match = {
                        id: `FS-${roundInfo.round}-${matchIndex + 1}`,
                        numericId: matchId++,
                        round: roundInfo.round,
                        side: 'frontside',
                        player1: player1,
                        player2: player2,
                        winner: null,
                        loser: null,
                        lane: matchIndex + 1,
                        legs: roundInfo.isLast ? config.legs.semifinal : config.legs.round1,
                        referee: null,
                        active: false,
                        completed: false,
                        positionInRound: matchIndex,
                        gridPosition: {
                            side: 'frontside',
                            round: roundInfo.round,
                            position: matchIndex
                        }
                    };
                    
                    // Auto-complete BYE matches
                    if (player1.isBye && !player2.isBye) {
                        match.winner = player2;
                        match.completed = true;
                    } else if (player2.isBye && !player1.isBye) {
                        match.winner = player1;
                        match.completed = true;
                    }
                    
                    matches.push(match);
                }
            });
        }

        function generateBacksideMatches(structure, startId) {
            let matchId = startId;
            
            structure.backside.forEach((roundInfo, roundIndex) => {
                for (let matchIndex = 0; matchIndex < roundInfo.matches; matchIndex++) {
                    const match = {
                        id: `BS-${roundInfo.round}-${matchIndex + 1}`,
                        numericId: matchId++,
                        round: roundInfo.round,
                        side: 'backside',
                        player1: { name: 'TBD', id: `bs-${roundInfo.round}-${matchIndex}-1` },
                        player2: { name: 'TBD', id: `bs-${roundInfo.round}-${matchIndex}-2` },
                        winner: null,
                        loser: null,
                        lane: matchIndex + 1,
                        legs: config.legs.round1,
                        referee: null,
                        active: false,
                        completed: false,
                        positionInRound: matchIndex,
                        receivesFromFrontside: roundInfo.receivesFromFrontside,
                        gridPosition: {
                            side: 'backside',
                            round: roundInfo.round,
                            position: matchIndex
                        }
                    };
                    
                    matches.push(match);
                }
            });
        }

        function generateFinalMatches(startId) {
            // Backside Final (if needed)
            const backsideFinal = {
                id: 'BS-FINAL',
                numericId: startId,
                round: 'backside-final',
                side: 'backside-final',
                player1: { name: 'Frontside Runner-up', id: 'fs-runnerup' },
                player2: { name: 'Backside Winner', id: 'bs-winner' },
                winner: null,
                loser: null,
                lane: 1,
                legs: config.legs.semifinal,
                referee: null,
                active: false,
                completed: false,
                gridPosition: {
                    side: 'backside-final',
                    round: 1,
                    position: 0
                }
            };
            
            // Grand Final
            const grandFinal = {
                id: 'GRAND-FINAL',
                numericId: startId + 1,
                round: 'grand-final',
                side: 'grand-final',
                player1: { name: 'Frontside Winner', id: 'fs-champion' },
                player2: { name: 'Backside Champion', id: 'bs-champion' },
                winner: null,
                loser: null,
                lane: 1,
                legs: config.legs.final,
                referee: null,
                active: false,
                completed: false,
                gridPosition: {
                    side: 'grand-final',
                    round: 1,
                    position: 0
                }
            };
            
            matches.push(backsideFinal);
            matches.push(grandFinal);
        }

        // BRACKET RENDERING SYSTEM - Complete Rewrite
        function renderBracket() {
            const canvas = document.getElementById('bracketCanvas');
            if (!canvas) return;
            
            if (!tournament || !tournament.bracket) {
                document.getElementById('bracketMatches').innerHTML = '<p style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #333;">No bracket generated yet</p>';
                return;
            }

            clearBracket();
            renderCompleteDoubleElimination();
        }

        function clearBracket() {
            document.getElementById('bracketMatches').innerHTML = '';
            document.getElementById('bracketLines').innerHTML = '';
        }

        function renderCompleteDoubleElimination() {
            const bracketSize = tournament.bracketSize;
            const structure = calculateBracketStructure(bracketSize);
            
            // Define grid parameters with doubled vertical spacing
            const grid = {
                matchWidth: 180,
                matchHeight: 80,
                horizontalSpacing: 100, 
                verticalSpacing: 60,   // Doubled from 30 to 60
                canvasWidth: 2000,
                canvasHeight: 1200,
                centerX: 1000,
                centerY: 600,
                centerBuffer: 250       
            };
            
            // Render all bracket sections
            renderFrontsideGrid(structure.frontside, grid);
            renderBacksideGrid(structure.backside, grid);
            renderFinalGrid(grid);
            renderAllConnections(structure, grid);
        }

        function renderFrontsideGrid(frontsideStructure, grid) {
            const totalRounds = frontsideStructure.length;
            
            frontsideStructure.forEach((roundInfo, roundIndex) => {
                const frontsideMatches = matches.filter(m => 
                    m.side === 'frontside' && m.round === roundInfo.round
                );
                
                // Position: Center flowing RIGHT with buffer zone
                const roundX = grid.centerX + grid.centerBuffer + roundIndex * (grid.matchWidth + grid.horizontalSpacing);
                
                // Calculate much better vertical spacing for frontside
                if (frontsideMatches.length === 1) {
                    // Final/semi-final match - center it vertically
                    const matchY = grid.centerY - (grid.matchHeight / 2);
                    renderGridMatch(frontsideMatches[0], roundX, matchY);
                } else {
                    // Multiple matches - use much more generous spacing
                    const totalNeededHeight = frontsideMatches.length * grid.matchHeight + (frontsideMatches.length - 1) * grid.verticalSpacing;
                    const startY = grid.centerY - (totalNeededHeight / 2);
                    
                    frontsideMatches.forEach((match, matchIndex) => {
                        const matchY = startY + matchIndex * (grid.matchHeight + grid.verticalSpacing);
                        renderGridMatch(match, roundX, matchY);
                    });
                }
            });
        }

        function renderBacksideGrid(backsideStructure, grid) {
            backsideStructure.forEach((roundInfo, roundIndex) => {
                const backsideMatches = matches.filter(m => 
                    m.side === 'backside' && m.round === roundInfo.round
                );
                
                // Position: Center flowing LEFT with buffer zone
                const roundX = grid.centerX - grid.centerBuffer - roundIndex * (grid.matchWidth + grid.horizontalSpacing);
                
                // Use the same improved vertical spacing logic as frontside
                if (backsideMatches.length === 1) {
                    // Single match in round - center it vertically
                    const matchY = grid.centerY - (grid.matchHeight / 2);
                    renderGridMatch(backsideMatches[0], roundX, matchY);
                } else {
                    // Multiple matches - use the same generous spacing as frontside
                    const totalNeededHeight = backsideMatches.length * grid.matchHeight + (backsideMatches.length - 1) * grid.verticalSpacing;
                    const startY = grid.centerY - (totalNeededHeight / 2);
                    
                    backsideMatches.forEach((match, matchIndex) => {
                        const matchY = startY + matchIndex * (grid.matchHeight + grid.verticalSpacing);
                        renderGridMatch(match, roundX, matchY);
                    });
                }
            });
        }

        function renderFinalGrid(grid) {
            const backsideFinal = matches.find(m => m.id === 'BS-FINAL');
            const grandFinal = matches.find(m => m.id === 'GRAND-FINAL');
            
            // Position finals at bottom center with better spacing
            const finalY = grid.centerY + 350; // A bit lower to give more space from brackets
            
            if (backsideFinal) {
                // Backside final positioned left of center, aligned with backside bracket
                renderGridMatch(backsideFinal, grid.centerX - 150, finalY);
            }
            
            if (grandFinal) {
                // Grand final centered horizontally and below backside final
                renderGridMatch(grandFinal, grid.centerX - (grid.matchWidth / 2), finalY + 150);
            }
        }

        function renderGridMatch(match, x, y) {
            const matchElement = document.createElement('div');
            matchElement.className = `bracket-match ${match.active ? 'active' : ''} ${match.completed ? 'completed' : ''}`;
            matchElement.style.left = x + 'px';
            matchElement.style.top = y + 'px';
            matchElement.id = `bracket-match-${match.id}`;

            const availableReferees = getAvailableReferees(match.id);
            const refereeOptions = availableReferees.map(ref => 
                `<option value="${ref.id}" ${match.referee?.id === ref.id ? 'selected' : ''}>${ref.name}</option>`
            ).join('');
            
            matchElement.innerHTML = `
                <div class="match-header">
                    <span>${match.id}</span>
                    <span class="match-info">
                        L<select onchange="updateMatchLane('${match.id}', this.value)" style="background: white; border: 1px solid #ddd; font-size: 11px; width: 40px; padding: 2px;">
                            ${Array.from({length: 10}, (_, i) => i + 1).map(lane => 
                                `<option value="${lane}" ${match.lane === lane ? 'selected' : ''}>${lane}</option>`
                            ).join('')}
                        </select> | Bo${match.legs}
                    </span>
                </div>
                <div class="match-players">
                    <div class="match-player ${match.player1?.isBye ? 'bye' : 'first-throw'} ${match.winner?.id === match.player1?.id ? 'winner' : ''}" 
                         onclick="${match.player1?.isBye ? '' : `selectWinner('${match.id}', 1)`}">
                        <span class="player-name-short">${match.player1?.name || 'TBD'}</span>
                        ${match.winner?.id === match.player1?.id ? '<span class="winner-check">✓</span>' : ''}
                    </div>
                    <div class="match-player ${match.player2?.isBye ? 'bye' : ''} ${match.winner?.id === match.player2?.id ? 'winner' : ''}" 
                         onclick="${match.player2?.isBye ? '' : `selectWinner('${match.id}', 2)`}">
                        <span class="player-name-short">${match.player2?.name || 'TBD'}</span>
                        ${match.winner?.id === match.player2?.id ? '<span class="winner-check">✓</span>' : ''}
                    </div>
                </div>
                <div class="match-controls">
                    <select onchange="updateReferee('${match.id}', this.value)" style="font-size: 11px; max-width: 80px; padding: 2px; background: white; border: 1px solid #ddd;">
                        <option value="">No ref</option>
                        ${refereeOptions}
                    </select>
                    <button onclick="toggleActive('${match.id}')" style="font-size: 8px; padding: 2px 4px; border: none; border-radius: 2px; background: ${match.active ? '#ff6b35' : '#ddd'}; color: ${match.active ? 'white' : 'black'};">
                        ${match.active ? 'LIVE' : 'Start'}
                    </button>
                </div>
            `;

            document.getElementById('bracketMatches').appendChild(matchElement);
        }

        function renderAllConnections(structure, grid) {
            // Clear existing lines
            document.getElementById('bracketLines').innerHTML = '';
            
            // Draw frontside connections
            drawFrontsideConnections(structure.frontside, grid);
            
            // Draw backside connections
            drawBacksideConnections(structure.backside, grid);
            
            // Draw loser drop connections
            drawLoserDropConnections(structure, grid);
            
            // Draw final connections
            drawFinalConnections(grid);
        }

        function drawFrontsideConnections(frontsideStructure, grid) {
            // Connect each round to the next in frontside bracket
            for (let roundIndex = 0; roundIndex < frontsideStructure.length - 1; roundIndex++) {
                const currentRound = frontsideStructure[roundIndex];
                const nextRound = frontsideStructure[roundIndex + 1];
                
                const currentMatches = matches.filter(m => 
                    m.side === 'frontside' && m.round === currentRound.round
                );
                const nextMatches = matches.filter(m => 
                    m.side === 'frontside' && m.round === nextRound.round
                );
                
                // Draw connections between pairs of current matches to next match
                for (let i = 0; i < nextMatches.length; i++) {
                    const match1 = currentMatches[i * 2];
                    const match2 = currentMatches[i * 2 + 1];
                    const nextMatch = nextMatches[i];
                    
                    if (match1 && match2 && nextMatch) {
                        drawTournamentConnection(match1.id, match2.id, nextMatch.id);
                    }
                }
            }
        }

        function drawBacksideConnections(backsideStructure, grid) {
            // Connect backside matches within their own flow
            for (let roundIndex = 0; roundIndex < backsideStructure.length - 1; roundIndex++) {
                const currentRound = backsideStructure[roundIndex];
                const nextRound = backsideStructure[roundIndex + 1];
                
                const currentMatches = matches.filter(m => 
                    m.side === 'backside' && m.round === currentRound.round
                );
                const nextMatches = matches.filter(m => 
                    m.side === 'backside' && m.round === nextRound.round
                );
                
                // Simple left-to-right flow for backside
                currentMatches.forEach((currentMatch, index) => {
                    const nextMatch = nextMatches[Math.floor(index / 2)];
                    if (nextMatch) {
                        drawSimpleConnection(currentMatch.id, nextMatch.id);
                    }
                });
            }
        }

        function drawLoserDropConnections(structure, grid) {
            // Draw connections from frontside losers to backside
            // This is where the double elimination magic happens
            
            structure.frontside.forEach((frontsideRound, index) => {
                if (index === structure.frontside.length - 1) return; // Skip final frontside round for now
                
                const frontsideMatches = matches.filter(m => 
                    m.side === 'frontside' && m.round === frontsideRound.round
                );
                
                // Find corresponding backside round that receives these losers
                const targetBacksideRound = index * 2 + 2; // Simplified logic
                const backsideMatches = matches.filter(m => 
                    m.side === 'backside' && m.round === targetBacksideRound
                );
                
                // Draw loser drop lines (simplified for now)
                frontsideMatches.forEach((fsMatch, fsIndex) => {
                    const bsMatch = backsideMatches[Math.floor(fsIndex / 2)];
                    if (bsMatch) {
                        drawLoserDropLine(fsMatch.id, bsMatch.id);
                    }
                });
            });
        }

        function drawFinalConnections(grid) {
            // Connect frontside winner to grand final
            const frontsideWinnerMatch = matches.find(m => 
                m.side === 'frontside' && m.round === Math.max(...matches.filter(m => m.side === 'frontside').map(m => m.round))
            );
            const grandFinal = matches.find(m => m.id === 'GRAND-FINAL');
            
            if (frontsideWinnerMatch && grandFinal) {
                drawSimpleConnection(frontsideWinnerMatch.id, grandFinal.id);
            }
            
            // Connect backside final to grand final
            const backsideFinal = matches.find(m => m.id === 'BS-FINAL');
            if (backsideFinal && grandFinal) {
                drawSimpleConnection(backsideFinal.id, grandFinal.id);
            }
        }

        function drawTournamentConnection(match1Id, match2Id, nextMatchId) {
            const match1Element = document.getElementById(`bracket-match-${match1Id}`);
            const match2Element = document.getElementById(`bracket-match-${match2Id}`);
            const nextMatchElement = document.getElementById(`bracket-match-${nextMatchId}`);
            
            if (!match1Element || !match2Element || !nextMatchElement) return;
            
            const linesContainer = document.getElementById('bracketLines');
            const canvasRect = document.getElementById('bracketCanvas').getBoundingClientRect();
            
            // Get positions
            const match1Rect = match1Element.getBoundingClientRect();
            const match2Rect = match2Element.getBoundingClientRect();
            const nextMatchRect = nextMatchElement.getBoundingClientRect();
            
            const match1Y = match1Rect.top - canvasRect.top + match1Rect.height / 2;
            const match2Y = match2Rect.top - canvasRect.top + match2Rect.height / 2;
            const nextMatchY = nextMatchRect.top - canvasRect.top + nextMatchRect.height / 2;
            const match1X = match1Rect.left - canvasRect.left + match1Rect.width;
            const nextMatchX = nextMatchRect.left - canvasRect.left;
            
            const connectorX = match1X + 40;
            
            // Horizontal lines from matches
            createLine(match1X, match1Y, connectorX, match1Y);
            createLine(match1X, match2Y, connectorX, match2Y);
            
            // Vertical connector
            createLine(connectorX, Math.min(match1Y, match2Y), connectorX, Math.max(match1Y, match2Y));
            
            // Line to next match
            createLine(connectorX, (match1Y + match2Y) / 2, nextMatchX, nextMatchY);
        }

        function drawSimpleConnection(fromMatchId, toMatchId) {
            const fromElement = document.getElementById(`bracket-match-${fromMatchId}`);
            const toElement = document.getElementById(`bracket-match-${toMatchId}`);
            
            if (!fromElement || !toElement) return;
            
            const canvasRect = document.getElementById('bracketCanvas').getBoundingClientRect();
            const fromRect = fromElement.getBoundingClientRect();
            const toRect = toElement.getBoundingClientRect();
            
            const fromX = fromRect.left - canvasRect.left + fromRect.width;
            const fromY = fromRect.top - canvasRect.top + fromRect.height / 2;
            const toX = toRect.left - canvasRect.left;
            const toY = toRect.top - canvasRect.top + toRect.height / 2;
            
            createLine(fromX, fromY, toX, toY);
        }

        function drawLoserDropLine(fromMatchId, toMatchId) {
            // Draw dashed line for loser drops
            const fromElement = document.getElementById(`bracket-match-${fromMatchId}`);
            const toElement = document.getElementById(`bracket-match-${toMatchId}`);
            
            if (!fromElement || !toElement) return;
            
            const canvasRect = document.getElementById('bracketCanvas').getBoundingClientRect();
            const fromRect = fromElement.getBoundingClientRect();
            const toRect = toElement.getBoundingClientRect();
            
            const fromX = fromRect.left - canvasRect.left + fromRect.width / 2;
            const fromY = fromRect.top - canvasRect.top + fromRect.height;
            const toX = toRect.left - canvasRect.left + toRect.width / 2;
            const toY = toRect.top - canvasRect.top;
            
            const line = document.createElement('div');
            line.className = 'bracket-line';
            line.style.position = 'absolute';
            line.style.background = '#ff6b35';
            line.style.borderStyle = 'dashed';
            line.style.borderWidth = '2px';
            line.style.borderColor = '#ff6b35';
            
            // Calculate line properties
            const dx = toX - fromX;
            const dy = toY - fromY;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            
            line.style.width = length + 'px';
            line.style.height = '0px';
            line.style.borderBottom = '2px dashed #ff6b35';
            line.style.left = fromX + 'px';
            line.style.top = fromY + 'px';
            line.style.transformOrigin = '0 0';
            line.style.transform = `rotate(${angle}deg)`;
            line.style.zIndex = '1';
            
            document.getElementById('bracketLines').appendChild(line);
        }

        function createLine(x1, y1, x2, y2) {
            const line = document.createElement('div');
            line.className = 'bracket-line';
            line.style.position = 'absolute';
            line.style.background = '#333333';
            line.style.zIndex = '1';
            
            if (Math.abs(x2 - x1) > Math.abs(y2 - y1)) {
                // Horizontal line
                line.style.left = Math.min(x1, x2) + 'px';
                line.style.top = y1 + 'px';
                line.style.width = Math.abs(x2 - x1) + 'px';
                line.style.height = '3px';
            } else {
                // Vertical line
                line.style.left = x1 + 'px';
                line.style.top = Math.min(y1, y2) + 'px';
                line.style.width = '3px';
                line.style.height = Math.abs(y2 - y1) + 'px';
            }
            
            document.getElementById('bracketLines').appendChild(line);
        }

        function selectWinner(matchId, playerNumber) {
            const match = matches.find(m => m.id === matchId);
            if (!match) return;

            const winner = playerNumber === 1 ? match.player1 : match.player2;
            const loser = playerNumber === 1 ? match.player2 : match.player1;

            if (winner.isBye || winner.name === 'TBD') return;

            // Toggle winner selection - if clicking same player, clear the winner
            if (match.winner?.id === winner.id) {
                match.winner = null;
                match.loser = null;
                match.completed = false;
                
                // TODO: Implement reverse advancement logic
            } else {
                // Set new winner
                match.winner = winner;
                match.loser = loser;
                match.completed = true;
                match.active = false;

                // Handle bracket progression logic
                advanceWinner(match);
            }
            
            saveTournament();
            renderBracket();
        }

        function advanceWinner(completedMatch) {
            const winner = completedMatch.winner;
            const loser = completedMatch.loser;
            
            if (!winner || !loser) return;
            
            // Handle different bracket advancement scenarios
            if (completedMatch.side === 'frontside') {
                advanceFrontsideWinner(completedMatch, winner);
                dropFrontsideLoser(completedMatch, loser);
            } else if (completedMatch.side === 'backside') {
                advanceBacksideWinner(completedMatch, winner);
                eliminateBacksideLoser(completedMatch, loser);
            } else if (completedMatch.side === 'backside-final') {
                advanceBacksideFinalWinner(completedMatch, winner);
            } else if (completedMatch.side === 'grand-final') {
                crownChampion(completedMatch, winner);
            }
        }

        function advanceFrontsideWinner(completedMatch, winner) {
            // Find next frontside match
            const currentRound = completedMatch.round;
            const nextRound = currentRound + 1;
            const positionInRound = completedMatch.positionInRound;
            const nextPosition = Math.floor(positionInRound / 2);
            
            const nextMatch = matches.find(m => 
                m.side === 'frontside' && 
                m.round === nextRound && 
                m.positionInRound === nextPosition
            );
            
            if (nextMatch) {
                // Determine if this winner goes to player1 or player2 slot
                const slot = (positionInRound % 2 === 0) ? 'player1' : 'player2';
                nextMatch[slot] = winner;
            } else {
                // This is the frontside champion
                const grandFinal = matches.find(m => m.id === 'GRAND-FINAL');
                if (grandFinal) {
                    grandFinal.player1 = winner;
                }
            }
        }

        function dropFrontsideLoser(completedMatch, loser) {
            // Calculate which backside round should receive this loser
            const frontsideRound = completedMatch.round;
            const structure = calculateBracketStructure(tournament.bracketSize);
            
            // Simplified logic - needs refinement based on exact double elimination rules
            let targetBacksideRound;
            if (frontsideRound === 1) {
                targetBacksideRound = 1; // First round losers go to backside round 1
            } else {
                targetBacksideRound = (frontsideRound - 1) * 2; // Approximate
            }
            
            // Find available slot in target backside round
            const targetMatches = matches.filter(m => 
                m.side === 'backside' && 
                m.round === targetBacksideRound &&
                (m.player1.name === 'TBD' || m.player2.name === 'TBD')
            );
            
            if (targetMatches.length > 0) {
                const targetMatch = targetMatches[0];
                if (targetMatch.player1.name === 'TBD') {
                    targetMatch.player1 = loser;
                } else if (targetMatch.player2.name === 'TBD') {
                    targetMatch.player2 = loser;
                }
            }
        }

        function advanceBacksideWinner(completedMatch, winner) {
            // Find next backside match
            const currentRound = completedMatch.round;
            const nextRound = currentRound + 1;
            const positionInRound = completedMatch.positionInRound;
            const nextPosition = Math.floor(positionInRound / 2);
            
            const nextMatch = matches.find(m => 
                m.side === 'backside' && 
                m.round === nextRound && 
                m.positionInRound === nextPosition
            );
            
            if (nextMatch) {
                const slot = (positionInRound % 2 === 0) ? 'player1' : 'player2';
                nextMatch[slot] = winner;
            } else {
                // This might be the backside champion
                const backsideFinal = matches.find(m => m.id === 'BS-FINAL');
                if (backsideFinal) {
                    backsideFinal.player2 = winner; // Backside winner
                }
            }
        }

        function eliminateBacksideLoser(completedMatch, loser) {
            // Mark player as eliminated
            const player = players.find(p => p.id === loser.id);
            if (player) {
                player.eliminated = true;
                // Assign placement based on current tournament state
                assignPlacement(player);
            }
        }

        function advanceBacksideFinalWinner(completedMatch, winner) {
            const grandFinal = matches.find(m => m.id === 'GRAND-FINAL');
            if (grandFinal) {
                grandFinal.player2 = winner; // Backside champion to grand final
            }
        }

        function crownChampion(completedMatch, winner) {
            const loser = completedMatch.loser;
            
            // Assign final placements
            const winnerPlayer = players.find(p => p.id === winner.id);
            const loserPlayer = players.find(p => p.id === loser.id);
            
            if (winnerPlayer) {
                winnerPlayer.placement = 1;
            }
            if (loserPlayer) {
                loserPlayer.placement = 2;
            }
            
            // Tournament is complete
            tournament.status = 'completed';
            displayResults();
        }

        function assignPlacement(player) {
            // Simple placement logic - could be more sophisticated
            const eliminatedCount = players.filter(p => p.eliminated).length;
            player.placement = eliminatedCount;
        }

        function displayResults() {
            // Show results section
            const resultsSection = document.getElementById('resultsSection');
            if (resultsSection) {
                resultsSection.style.display = 'block';
                updateResultsTable();
            }
        }

        function updateResultsTable() {
            const tbody = document.getElementById('resultsTableBody');
            if (!tbody) return;
            
            // Sort players by placement
            const sortedPlayers = [...players].sort((a, b) => {
                if (a.placement && b.placement) {
                    return a.placement - b.placement;
                }
                if (a.placement) return -1;
                if (b.placement) return 1;
                return 0;
            });
            
            tbody.innerHTML = sortedPlayers.map(player => {
                const points = calculatePlayerPoints(player);
                return `
                    <tr>
                        <td>${player.placement || 'TBD'}</td>
                        <td>${player.name}</td>
                        <td>${points}</td>
                        <td>${player.stats.shortLegs || 0}</td>
                        <td>${(player.stats.highOuts || []).length}</td>
                        <td>${player.stats.tons || 0}</td>
                        <td>${player.stats.oneEighties || 0}</td>
                    </tr>
                `;
            }).join('');
        }

        function calculatePlayerPoints(player) {
            let points = 0;
            
            // Participation points
            points += config.points.participation;
            
            // Placement points
            if (player.placement === 1) {
                points += config.points.first;
            } else if (player.placement === 2) {
                points += config.points.second;
            } else if (player.placement === 3) {
                points += config.points.third;
            }
            
            // Statistics points
            points += (player.stats.highOuts || []).length * config.points.highOut;
            points += (player.stats.tons || 0) * config.points.ton;
            points += (player.stats.oneEighties || 0) * config.points.oneEighty;
            
            return points;
        }

        function updateMatchLane(matchId, newLane) {
            const match = matches.find(m => m.id === matchId);
            if (!match) return;

            match.lane = parseInt(newLane);
            saveTournament();
        }

        function updateReferee(matchId, refereeId) {
            const match = matches.find(m => m.id === matchId);
            if (!match) return;

            if (refereeId === '') {
                match.referee = null;
            } else {
                const referee = players.find(p => p.id == refereeId);
                match.referee = referee || null;
            }
            
            saveTournament();
            renderBracket();
        }

        function getAvailableReferees(matchId) {
            const match = matches.find(m => m.id === matchId);
            if (!match) return [];

            return players.filter(player => 
                !player.eliminated && 
                player.paid &&
                player.id !== match.player1?.id && 
                player.id !== match.player2?.id &&
                !player.isBye &&
                player.name !== 'TBD'
            );
        }

        function toggleActive(matchId) {
            const match = matches.find(m => m.id === matchId);
            if (!match) return;

            match.active = !match.active;
            saveTournament();
            renderBracket();
        }

        // Zoom and pan functionality
        function handleZoom(e) {
            e.preventDefault();
            
            // Get mouse position relative to viewport
            const viewport = document.getElementById('bracketViewport');
            const rect = viewport.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Calculate mouse position in canvas coordinates
            const canvasMouseX = (mouseX - panOffset.x) / zoomLevel;
            const canvasMouseY = (mouseY - panOffset.y) / zoomLevel;
            
            // Small zoom increments
            const delta = e.deltaY > 0 ? -0.05 : 0.05;
            const newZoom = Math.max(0.3, Math.min(2, zoomLevel + delta));
            
            if (newZoom !== zoomLevel) {
                // Calculate new pan offset to keep mouse position centered
                panOffset.x = mouseX - canvasMouseX * newZoom;
                panOffset.y = mouseY - canvasMouseY * newZoom;
                
                zoomLevel = newZoom;
                updateCanvasTransform();
            }
        }

        function zoomIn() {
            const viewport = document.getElementById('bracketViewport');
            const centerX = viewport.clientWidth / 2;
            const centerY = viewport.clientHeight / 2;
            
            const canvasCenterX = (centerX - panOffset.x) / zoomLevel;
            const canvasCenterY = (centerY - panOffset.y) / zoomLevel;
            
            zoomLevel = Math.min(2, zoomLevel + 0.1);
            
            panOffset.x = centerX - canvasCenterX * zoomLevel;
            panOffset.y = centerY - canvasCenterY * zoomLevel;
            
            updateCanvasTransform();
        }

        function zoomOut() {
            const viewport = document.getElementById('bracketViewport');
            const centerX = viewport.clientWidth / 2;
            const centerY = viewport.clientHeight / 2;
            
            const canvasCenterX = (centerX - panOffset.x) / zoomLevel;
            const canvasCenterY = (centerY - panOffset.y) / zoomLevel;
            
            zoomLevel = Math.max(0.3, zoomLevel - 0.1);
            
            panOffset.x = centerX - canvasCenterX * zoomLevel;
            panOffset.y = centerY - canvasCenterY * zoomLevel;
            
            updateCanvasTransform();
        }

        function resetZoom() {
            zoomLevel = 0.6; // Start more zoomed out to show full tournament
            panOffset = { x: 0, y: 0 };
            updateCanvasTransform();
        }

        function updateCanvasTransform() {
            const canvas = document.getElementById('bracketCanvas');
            if (canvas) {
                canvas.style.transform = `translate(${panOffset.x}px, ${panOffset.y}px) scale(${zoomLevel})`;
            }
        }

        function startDrag(e) {
            if (e.target.closest('.bracket-match')) return; // Don't drag when clicking matches
            isDragging = true;
            dragStart.x = e.clientX - panOffset.x;
            dragStart.y = e.clientY - panOffset.y;
            e.preventDefault();
        }

        function handleDrag(e) {
            if (!isDragging) return;
            panOffset.x = e.clientX - dragStart.x;
            panOffset.y = e.clientY - dragStart.y;
            updateCanvasTransform();
        }

        function endDrag() {
            isDragging = false;
        }

        function autoAssignReferees() {
            // Get all active matches that need referees
            const activeMatches = matches.filter(m => 
                !m.completed && 
                (m.player1.name !== 'TBD' && m.player2.name !== 'TBD') &&
                !m.referee
            );
            
            if (activeMatches.length === 0) {
                alert('No matches need referee assignment');
                return;
            }
            
            // Get available referees (eliminated players first)
            const eliminatedRefs = players.filter(p => p.eliminated && p.paid);
            const activeRefs = players.filter(p => !p.eliminated && p.paid);
            
            // Prioritize eliminated players as referees
            const availableRefs = [...eliminatedRefs, ...activeRefs];
            
            let refIndex = 0;
            activeMatches.forEach(match => {
                // Find referee who is not playing in this match
                const availableForMatch = availableRefs.filter(ref => 
                    ref.id !== match.player1.id && 
                    ref.id !== match.player2.id
                );
                
                if (availableForMatch.length > 0) {
                    match.referee = availableForMatch[refIndex % availableForMatch.length];
                    refIndex++;
                }
            });
            
            saveTournament();
            renderBracket();
            alert(`Assigned referees to ${activeMatches.filter(m => m.referee).length} matches`);
        }

        function resetTournament() {
            if (confirm('Are you sure you want to reset the tournament? This will clear all matches and results.')) {
                matches = [];
                tournament.bracket = null;
                tournament.status = 'setup';
                
                players.forEach(player => {
                    player.eliminated = false;
                    player.placement = null;
                });

                saveTournament();
                clearBracket();
                
                // Hide results section
                const resultsSection = document.getElementById('resultsSection');
                if (resultsSection) {
                    resultsSection.style.display = 'none';
                }
                
                alert('Tournament reset successfully');
            }
        }

        function showMatchDetails() {
            const activeMatches = matches.filter(m => m.active);
            const upcomingMatches = matches.filter(m => 
                !m.completed && 
                m.player1.name !== 'TBD' && 
                m.player2.name !== 'TBD'
            );
            
            let details = `Active Matches: ${activeMatches.length}\n`;
            details += `Upcoming Matches: ${upcomingMatches.length}\n`;
            details += `Completed Matches: ${matches.filter(m => m.completed).length}\n\n`;
            
            if (activeMatches.length > 0) {
                details += 'Active Matches:\n';
                activeMatches.forEach(match => {
                    details += `${match.id}: ${match.player1.name} vs ${match.player2.name} (Lane ${match.lane})\n`;
                });
            }
            
            alert(details);
        }

        function loadConfiguration() {
            const savedConfig = localStorage.getItem('dartsConfig');
            if (savedConfig) {
                config = JSON.parse(savedConfig);
                
                // Update UI elements
                document.getElementById('participationPoints').value = config.points.participation;
                document.getElementById('firstPlacePoints').value = config.points.first;
                document.getElementById('secondPlacePoints').value = config.points.second;
                document.getElementById('thirdPlacePoints').value = config.points.third;
                document.getElementById('highOutPoints').value = config.points.highOut;
                document.getElementById('tonPoints').value = config.points.ton;
                document.getElementById('oneEightyPoints').value = config.points.oneEighty;
                
                document.getElementById('round1Legs').value = config.legs.round1;
                document.getElementById('round2Legs').value = config.legs.round2;
                document.getElementById('semifinalLegs').value = config.legs.semifinal;
                document.getElementById('finalLegs').value = config.legs.final;
            }
        }

        function saveConfiguration() {
            // Update config object
            config.points.participation = parseInt(document.getElementById('participationPoints').value);
            config.points.first = parseInt(document.getElementById('firstPlacePoints').value);
            config.points.second = parseInt(document.getElementById('secondPlacePoints').value);
            config.points.third = parseInt(document.getElementById('thirdPlacePoints').value);
            config.points.highOut = parseInt(document.getElementById('highOutPoints').value);
            config.points.ton = parseInt(document.getElementById('tonPoints').value);
            config.points.oneEighty = parseInt(document.getElementById('oneEightyPoints').value);
            
            config.legs.round1 = parseInt(document.getElementById('round1Legs').value);
            config.legs.round2 = parseInt(document.getElementById('round2Legs').value);
            config.legs.semifinal = parseInt(document.getElementById('semifinalLegs').value);
            config.legs.final = parseInt(document.getElementById('finalLegs').value);
            
            localStorage.setItem('dartsConfig', JSON.stringify(config));
            alert('Configuration saved successfully!');
        }

        // Auto-load current tournament on page load
        window.addEventListener('load', function() {
            const currentTournament = localStorage.getItem('currentTournament');
            if (currentTournament) {
                try {
                    tournament = JSON.parse(currentTournament);
                    players = tournament.players || [];
                    matches = tournament.matches || [];
                    
                    if (tournament.name && tournament.date) {
                        document.getElementById('tournamentName').value = tournament.name;
                        document.getElementById('tournamentDate').value = tournament.date;
                        updateTournamentStatus();
                        updatePlayersDisplay();
                        updatePlayerCount();
                        
                        if (tournament.bracket && matches.length > 0) {
                            renderBracket();
                        }
                        
                        if (tournament.status === 'completed') {
                            displayResults();
                        }
                    }
                } catch (e) {
                    console.error('Error loading current tournament:', e);
                }
            }
        });
    </script>
</body>
</html>
